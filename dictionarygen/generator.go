package dictionarygen

import (
	"bytes"
	"errors"
	"go/format"
	"strconv"

	"layeh.com/radius/dictionary"
)

type externalAttribute struct {
	Attribute  string
	ImportPath string

	Values []*dictionary.Value
}

type Generator struct {
	// Output package name.
	Package string
	// Attributes that will be ignored during generation.
	IgnoredAttributes []string
	// Map of external attributes to import path where the attribute is
	// defined.
	ExternalAttributes map[string]string
}

func (g *Generator) Generate(dict *dictionary.Dictionary) ([]byte, error) {

	attrs := make([]*dictionary.Attribute, 0, len(dict.Attributes))

	ignoredAttributes := make(map[string]struct{}, len(g.IgnoredAttributes))
	for _, attrName := range g.IgnoredAttributes {
		ignoredAttributes[attrName] = struct{}{}
	}

	baseImports := map[string]struct{}{}

	for _, attr := range dict.Attributes {
		if _, ignored := ignoredAttributes[attr.Name]; ignored {
			continue
		}

		invalid := false
		if attr.Size != nil {
			invalid = true
		}
		if attr.FlagHasTag != nil {
			invalid = true
		}
		if attr.FlagEncrypt != nil && *attr.FlagEncrypt != 1 {
			invalid = true
		}
		switch attr.Type {
		case dictionary.AttributeString:
		case dictionary.AttributeOctets:
		case dictionary.AttributeIPAddr:
			baseImports["net"] = struct{}{}
		case dictionary.AttributeDate:
			baseImports["time"] = struct{}{}
		case dictionary.AttributeInteger:
			baseImports["strconv"] = struct{}{}
		case dictionary.AttributeVSA:
		default:
			invalid = true
		}

		if invalid {
			return nil, errors.New("dictionarygen: cannot generate code for attribute " + attr.Name)
		}

		attrs = append(attrs, attr)
	}

	dictionary.SortAttributes(attrs)

	externalAttributes := make([]*externalAttribute, 0, len(g.ExternalAttributes))
	for attribute, importPath := range g.ExternalAttributes {
		externalAttributes = append(externalAttributes, &externalAttribute{
			Attribute:  attribute,
			ImportPath: importPath,
		})
	}
	sortExternalAttributes(externalAttributes)

	values := make([]*dictionary.Value, 0, len(dict.Values))
	for _, value := range dict.Values {
		if _, ignored := ignoredAttributes[value.Attribute]; ignored {
			continue
		}

		var isLocalAttr bool
		for _, attr := range attrs {
			if value.Attribute == attr.Name {
				isLocalAttr = true
				break
			}
		}
		if isLocalAttr {
			values = append(values, value)
			continue
		}

		var ea *externalAttribute
		for _, exAttr := range externalAttributes {
			if value.Attribute == exAttr.Attribute {
				ea = exAttr
				break
			}
		}
		if ea == nil {
			return nil, errors.New("dictionarygen: unknown attribute " + value.Attribute)
		}

		ea.Values = append(ea.Values, value)
	}
	dictionary.SortValues(values)

	vendors := make([]*dictionary.Vendor, 0, len(dict.Vendors))
	for _, vendor := range dict.Vendors {
		if vendor.LengthOctets != 1 || vendor.TypeOctets != 1 {
			return nil, errors.New("dictionarygen: cannot generate code for " + vendor.Name)
		}

		for _, attr := range vendor.Attributes {
			invalid := false
			if attr.Size != nil {
				invalid = true
			}
			if attr.FlagHasTag != nil {
				invalid = true
			}
			if attr.FlagEncrypt != nil && *attr.FlagEncrypt != 1 {
				invalid = true
			}
			switch attr.Type {
			case dictionary.AttributeString:
			case dictionary.AttributeOctets:
			case dictionary.AttributeIPAddr:
				baseImports["net"] = struct{}{}
			case dictionary.AttributeDate:
				baseImports["time"] = struct{}{}
			case dictionary.AttributeInteger:
				baseImports["strconv"] = struct{}{}
			default:
				invalid = true
			}

			if invalid {
				return nil, errors.New("dictionarygen: cannot generate code for " + vendor.Name + " vendor attribute " + attr.Name)
			}
		}

		vendorAttributes := make([]*dictionary.Attribute, len(vendor.Attributes))
		copy(vendorAttributes, vendor.Attributes)
		dictionary.SortAttributes(vendorAttributes)

		vendorValues := make([]*dictionary.Value, len(vendor.Values))
		copy(vendorValues, vendor.Values)
		dictionary.SortValues(vendorValues)

		vendors = append(vendors, &dictionary.Vendor{
			Name:   vendor.Name,
			Number: vendor.Number,

			TypeOctets:   vendor.TypeOctets,
			LengthOctets: vendor.LengthOctets,

			Attributes: vendorAttributes,
			Values:     vendorValues,
		})
	}
	dictionary.SortVendors(vendors)

	var w bytes.Buffer

	p(&w, `// Generated by radius-dict-gen. DO NOT EDIT.`)
	p(&w)
	p(&w, `package `, g.Package)

	// Imports
	p(&w)
	p(&w, `import (`)
	for imprt := range baseImports {
		p(&w, `	`+strconv.Quote(imprt))
	}
	if len(attrs) > 0 || len(vendors) > 0 {
		p(&w)
		p(&w, `	"layeh.com/radius"`)
	}
	if len(vendors) > 0 {
		p(&w, `	"layeh.com/radius/rfc2865"`)
	}
	if len(externalAttributes) > 0 {
		printedNewLine := false
		for _, exAttr := range externalAttributes {
			if len(exAttr.Values) > 0 {
				if !printedNewLine {
					p(&w)
					printedNewLine = true
				}
				p(&w, `	. `, strconv.Quote(exAttr.ImportPath))
			}
		}
	}
	p(&w, `)`)

	// Attribute types
	if len(attrs) > 0 {
		p(&w)
		p(&w, `const (`)
		for _, attr := range attrs {
			p(&w, `	`, identifier(attr.Name), `_Type radius.Type = `, attr.OID)
		}
		p(&w, `)`)
		g.genAttributeStringLookups(&w, attrs, "_Type", "radius.Type")
	}

	if len(vendors) > 0 {
		p(&w)
		p(&w, `const (`)
		for _, vendor := range vendors {
			p(&w, `	_`, identifier(vendor.Name), `_VendorID = `, strconv.Itoa(vendor.Number))
		}
		p(&w, `)`)
	}

	for _, exAttr := range externalAttributes {
		p(&w)
		p(&w, `func init() {`)
		for _, value := range exAttr.Values {
			attrIdent := identifier(value.Attribute)
			valueIdent := identifier(value.Name)
			p(&w, `	`, attrIdent, `_Strings[`, attrIdent, `_Value_`, valueIdent, `] = `, strconv.Quote(value.Name))
		}
		p(&w, `}`)

		p(&w)
		p(&w, `const (`)
		for _, value := range exAttr.Values {
			attrIdent := identifier(value.Attribute)
			valueIdent := identifier(value.Name)
			p(&w, `	`, attrIdent, `_Value_`, valueIdent, ` `, attrIdent, ` = `, strconv.Itoa(value.Number))
		}
		p(&w, `)`)
	}

	for _, attr := range attrs {
		switch attr.Type {
		case dictionary.AttributeString, dictionary.AttributeOctets:
			g.genAttributeStringOctets(&w, attr, nil)
		case dictionary.AttributeIPAddr:
			g.genAttributeIPAddr(&w, attr, nil)
		case dictionary.AttributeDate:
			g.genAttributeDate(&w, attr, nil)
		case dictionary.AttributeInteger:
			g.genAttributeInteger(&w, attr, values, nil)
		case dictionary.AttributeVSA:
			// skip
		}
	}

	for _, vendor := range vendors {
		g.genVendor(&w, vendor)
		for _, attr := range vendor.Attributes {
			switch attr.Type {
			case dictionary.AttributeString, dictionary.AttributeOctets:
				g.genAttributeStringOctets(&w, attr, vendor)
			case dictionary.AttributeIPAddr:
				g.genAttributeIPAddr(&w, attr, vendor)
			case dictionary.AttributeDate:
				g.genAttributeDate(&w, attr, vendor)
			case dictionary.AttributeInteger:
				g.genAttributeInteger(&w, attr, vendor.Values, vendor)
			}
		}
	}

	formatted, err := format.Source(w.Bytes())
	if err != nil {
		return nil, err
	}
	return formatted, nil
}
