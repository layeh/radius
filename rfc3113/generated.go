// Code generated by radius-dict-gen. DO NOT EDIT.

package rfc3113

import (
	"errors"
	"net"
	"strconv"

	"layeh.com/radius"
)

const (
	IMSI_Type                       radius.Type = 1
	ChargingID_Type                 radius.Type = 2
	PDPType_Type                    radius.Type = 3
	ChargingGatewayAddress_Type     radius.Type = 4
	GPRSNegotiatedQoSProfile_Type   radius.Type = 5
	SGSNAddress_Type                radius.Type = 6
	GGSNAddress_Type                radius.Type = 7
	IMSIMCCMNC_Type                 radius.Type = 8
	GGSNMCCMNC_Type                 radius.Type = 9
	NSAPI_Type                      radius.Type = 10
	SessionStopIndicator_Type       radius.Type = 11
	SelectionMode_Type              radius.Type = 12
	ChargingCharacteristics_Type    radius.Type = 13
	ChargingGatewayIPv6Address_Type radius.Type = 14
	SGSNIPv6Address_Type            radius.Type = 15
	GGSNIPv6Address_Type            radius.Type = 16
	IPv6DNSServers_Type             radius.Type = 17
	SGSNMCCMNC_Type                 radius.Type = 18
	TeardownIndicator_Type          radius.Type = 19
	IMEISV_Type                     radius.Type = 20
	RATType_Type                    radius.Type = 21
	LocationInfo_Type               radius.Type = 22
	MSTimeZone_Type                 radius.Type = 23
	CamelChargingInfo_Type          radius.Type = 24
	PacketFilter_Type               radius.Type = 25
	NegotiatedDSCP_Type             radius.Type = 26
	AllocateIPType_Type             radius.Type = 27
)

func IMSI_Add(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Add(IMSI_Type, a)
	return
}

func IMSI_AddString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Add(IMSI_Type, a)
	return
}

func IMSI_Get(p *radius.Packet) (value []byte) {
	value, _ = IMSI_Lookup(p)
	return
}

func IMSI_GetString(p *radius.Packet) (value string) {
	value, _ = IMSI_LookupString(p)
	return
}

func IMSI_Gets(p *radius.Packet) (values [][]byte, err error) {
	var i []byte
	for _, avp := range p.Attributes {
		if avp.Type != IMSI_Type {
			continue
		}
		attr := avp.Attribute
		i = radius.Bytes(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func IMSI_GetStrings(p *radius.Packet) (values []string, err error) {
	var i string
	for _, avp := range p.Attributes {
		if avp.Type != IMSI_Type {
			continue
		}
		attr := avp.Attribute
		i = radius.String(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func IMSI_Lookup(p *radius.Packet) (value []byte, err error) {
	a, ok := p.Lookup(IMSI_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.Bytes(a)
	return
}

func IMSI_LookupString(p *radius.Packet) (value string, err error) {
	a, ok := p.Lookup(IMSI_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.String(a)
	return
}

func IMSI_Set(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Set(IMSI_Type, a)
	return
}

func IMSI_SetString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Set(IMSI_Type, a)
	return
}

func IMSI_Del(p *radius.Packet) {
	p.Attributes.Del(IMSI_Type)
}

type ChargingID uint32

var ChargingID_Strings = map[ChargingID]string{}

func (a ChargingID) String() string {
	if str, ok := ChargingID_Strings[a]; ok {
		return str
	}
	return "ChargingID(" + strconv.FormatUint(uint64(a), 10) + ")"
}

func ChargingID_Add(p *radius.Packet, value ChargingID) (err error) {
	a := radius.NewInteger(uint32(value))
	p.Add(ChargingID_Type, a)
	return
}

func ChargingID_Get(p *radius.Packet) (value ChargingID) {
	value, _ = ChargingID_Lookup(p)
	return
}

func ChargingID_Gets(p *radius.Packet) (values []ChargingID, err error) {
	var i uint32
	for _, avp := range p.Attributes {
		if avp.Type != ChargingID_Type {
			continue
		}
		attr := avp.Attribute
		i, err = radius.Integer(attr)
		if err != nil {
			return
		}
		values = append(values, ChargingID(i))
	}
	return
}

func ChargingID_Lookup(p *radius.Packet) (value ChargingID, err error) {
	a, ok := p.Lookup(ChargingID_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	var i uint32
	i, err = radius.Integer(a)
	if err != nil {
		return
	}
	value = ChargingID(i)
	return
}

func ChargingID_Set(p *radius.Packet, value ChargingID) (err error) {
	a := radius.NewInteger(uint32(value))
	p.Set(ChargingID_Type, a)
	return
}

func ChargingID_Del(p *radius.Packet) {
	p.Attributes.Del(ChargingID_Type)
}

type PDPType uint32

var PDPType_Strings = map[PDPType]string{}

func (a PDPType) String() string {
	if str, ok := PDPType_Strings[a]; ok {
		return str
	}
	return "PDPType(" + strconv.FormatUint(uint64(a), 10) + ")"
}

func PDPType_Add(p *radius.Packet, value PDPType) (err error) {
	a := radius.NewInteger(uint32(value))
	p.Add(PDPType_Type, a)
	return
}

func PDPType_Get(p *radius.Packet) (value PDPType) {
	value, _ = PDPType_Lookup(p)
	return
}

func PDPType_Gets(p *radius.Packet) (values []PDPType, err error) {
	var i uint32
	for _, avp := range p.Attributes {
		if avp.Type != PDPType_Type {
			continue
		}
		attr := avp.Attribute
		i, err = radius.Integer(attr)
		if err != nil {
			return
		}
		values = append(values, PDPType(i))
	}
	return
}

func PDPType_Lookup(p *radius.Packet) (value PDPType, err error) {
	a, ok := p.Lookup(PDPType_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	var i uint32
	i, err = radius.Integer(a)
	if err != nil {
		return
	}
	value = PDPType(i)
	return
}

func PDPType_Set(p *radius.Packet, value PDPType) (err error) {
	a := radius.NewInteger(uint32(value))
	p.Set(PDPType_Type, a)
	return
}

func PDPType_Del(p *radius.Packet) {
	p.Attributes.Del(PDPType_Type)
}

func ChargingGatewayAddress_Add(p *radius.Packet, value net.IP) (err error) {
	var a radius.Attribute
	a, err = radius.NewIPAddr(value)
	if err != nil {
		return
	}
	p.Add(ChargingGatewayAddress_Type, a)
	return
}

func ChargingGatewayAddress_Get(p *radius.Packet) (value net.IP) {
	value, _ = ChargingGatewayAddress_Lookup(p)
	return
}

func ChargingGatewayAddress_Gets(p *radius.Packet) (values []net.IP, err error) {
	var i net.IP
	for _, avp := range p.Attributes {
		if avp.Type != ChargingGatewayAddress_Type {
			continue
		}
		attr := avp.Attribute
		i, err = radius.IPAddr(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func ChargingGatewayAddress_Lookup(p *radius.Packet) (value net.IP, err error) {
	a, ok := p.Lookup(ChargingGatewayAddress_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value, err = radius.IPAddr(a)
	return
}

func ChargingGatewayAddress_Set(p *radius.Packet, value net.IP) (err error) {
	var a radius.Attribute
	a, err = radius.NewIPAddr(value)
	if err != nil {
		return
	}
	p.Set(ChargingGatewayAddress_Type, a)
	return
}

func ChargingGatewayAddress_Del(p *radius.Packet) {
	p.Attributes.Del(ChargingGatewayAddress_Type)
}

func GPRSNegotiatedQoSProfile_Add(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Add(GPRSNegotiatedQoSProfile_Type, a)
	return
}

func GPRSNegotiatedQoSProfile_AddString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Add(GPRSNegotiatedQoSProfile_Type, a)
	return
}

func GPRSNegotiatedQoSProfile_Get(p *radius.Packet) (value []byte) {
	value, _ = GPRSNegotiatedQoSProfile_Lookup(p)
	return
}

func GPRSNegotiatedQoSProfile_GetString(p *radius.Packet) (value string) {
	value, _ = GPRSNegotiatedQoSProfile_LookupString(p)
	return
}

func GPRSNegotiatedQoSProfile_Gets(p *radius.Packet) (values [][]byte, err error) {
	var i []byte
	for _, avp := range p.Attributes {
		if avp.Type != GPRSNegotiatedQoSProfile_Type {
			continue
		}
		attr := avp.Attribute
		i = radius.Bytes(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func GPRSNegotiatedQoSProfile_GetStrings(p *radius.Packet) (values []string, err error) {
	var i string
	for _, avp := range p.Attributes {
		if avp.Type != GPRSNegotiatedQoSProfile_Type {
			continue
		}
		attr := avp.Attribute
		i = radius.String(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func GPRSNegotiatedQoSProfile_Lookup(p *radius.Packet) (value []byte, err error) {
	a, ok := p.Lookup(GPRSNegotiatedQoSProfile_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.Bytes(a)
	return
}

func GPRSNegotiatedQoSProfile_LookupString(p *radius.Packet) (value string, err error) {
	a, ok := p.Lookup(GPRSNegotiatedQoSProfile_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.String(a)
	return
}

func GPRSNegotiatedQoSProfile_Set(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Set(GPRSNegotiatedQoSProfile_Type, a)
	return
}

func GPRSNegotiatedQoSProfile_SetString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Set(GPRSNegotiatedQoSProfile_Type, a)
	return
}

func GPRSNegotiatedQoSProfile_Del(p *radius.Packet) {
	p.Attributes.Del(GPRSNegotiatedQoSProfile_Type)
}

func SGSNAddress_Add(p *radius.Packet, value net.IP) (err error) {
	var a radius.Attribute
	a, err = radius.NewIPAddr(value)
	if err != nil {
		return
	}
	p.Add(SGSNAddress_Type, a)
	return
}

func SGSNAddress_Get(p *radius.Packet) (value net.IP) {
	value, _ = SGSNAddress_Lookup(p)
	return
}

func SGSNAddress_Gets(p *radius.Packet) (values []net.IP, err error) {
	var i net.IP
	for _, avp := range p.Attributes {
		if avp.Type != SGSNAddress_Type {
			continue
		}
		attr := avp.Attribute
		i, err = radius.IPAddr(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func SGSNAddress_Lookup(p *radius.Packet) (value net.IP, err error) {
	a, ok := p.Lookup(SGSNAddress_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value, err = radius.IPAddr(a)
	return
}

func SGSNAddress_Set(p *radius.Packet, value net.IP) (err error) {
	var a radius.Attribute
	a, err = radius.NewIPAddr(value)
	if err != nil {
		return
	}
	p.Set(SGSNAddress_Type, a)
	return
}

func SGSNAddress_Del(p *radius.Packet) {
	p.Attributes.Del(SGSNAddress_Type)
}

func GGSNAddress_Add(p *radius.Packet, value net.IP) (err error) {
	var a radius.Attribute
	a, err = radius.NewIPAddr(value)
	if err != nil {
		return
	}
	p.Add(GGSNAddress_Type, a)
	return
}

func GGSNAddress_Get(p *radius.Packet) (value net.IP) {
	value, _ = GGSNAddress_Lookup(p)
	return
}

func GGSNAddress_Gets(p *radius.Packet) (values []net.IP, err error) {
	var i net.IP
	for _, avp := range p.Attributes {
		if avp.Type != GGSNAddress_Type {
			continue
		}
		attr := avp.Attribute
		i, err = radius.IPAddr(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func GGSNAddress_Lookup(p *radius.Packet) (value net.IP, err error) {
	a, ok := p.Lookup(GGSNAddress_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value, err = radius.IPAddr(a)
	return
}

func GGSNAddress_Set(p *radius.Packet, value net.IP) (err error) {
	var a radius.Attribute
	a, err = radius.NewIPAddr(value)
	if err != nil {
		return
	}
	p.Set(GGSNAddress_Type, a)
	return
}

func GGSNAddress_Del(p *radius.Packet) {
	p.Attributes.Del(GGSNAddress_Type)
}

func IMSIMCCMNC_Add(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Add(IMSIMCCMNC_Type, a)
	return
}

func IMSIMCCMNC_AddString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Add(IMSIMCCMNC_Type, a)
	return
}

func IMSIMCCMNC_Get(p *radius.Packet) (value []byte) {
	value, _ = IMSIMCCMNC_Lookup(p)
	return
}

func IMSIMCCMNC_GetString(p *radius.Packet) (value string) {
	value, _ = IMSIMCCMNC_LookupString(p)
	return
}

func IMSIMCCMNC_Gets(p *radius.Packet) (values [][]byte, err error) {
	var i []byte
	for _, avp := range p.Attributes {
		if avp.Type != IMSIMCCMNC_Type {
			continue
		}
		attr := avp.Attribute
		i = radius.Bytes(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func IMSIMCCMNC_GetStrings(p *radius.Packet) (values []string, err error) {
	var i string
	for _, avp := range p.Attributes {
		if avp.Type != IMSIMCCMNC_Type {
			continue
		}
		attr := avp.Attribute
		i = radius.String(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func IMSIMCCMNC_Lookup(p *radius.Packet) (value []byte, err error) {
	a, ok := p.Lookup(IMSIMCCMNC_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.Bytes(a)
	return
}

func IMSIMCCMNC_LookupString(p *radius.Packet) (value string, err error) {
	a, ok := p.Lookup(IMSIMCCMNC_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.String(a)
	return
}

func IMSIMCCMNC_Set(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Set(IMSIMCCMNC_Type, a)
	return
}

func IMSIMCCMNC_SetString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Set(IMSIMCCMNC_Type, a)
	return
}

func IMSIMCCMNC_Del(p *radius.Packet) {
	p.Attributes.Del(IMSIMCCMNC_Type)
}

func GGSNMCCMNC_Add(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Add(GGSNMCCMNC_Type, a)
	return
}

func GGSNMCCMNC_AddString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Add(GGSNMCCMNC_Type, a)
	return
}

func GGSNMCCMNC_Get(p *radius.Packet) (value []byte) {
	value, _ = GGSNMCCMNC_Lookup(p)
	return
}

func GGSNMCCMNC_GetString(p *radius.Packet) (value string) {
	value, _ = GGSNMCCMNC_LookupString(p)
	return
}

func GGSNMCCMNC_Gets(p *radius.Packet) (values [][]byte, err error) {
	var i []byte
	for _, avp := range p.Attributes {
		if avp.Type != GGSNMCCMNC_Type {
			continue
		}
		attr := avp.Attribute
		i = radius.Bytes(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func GGSNMCCMNC_GetStrings(p *radius.Packet) (values []string, err error) {
	var i string
	for _, avp := range p.Attributes {
		if avp.Type != GGSNMCCMNC_Type {
			continue
		}
		attr := avp.Attribute
		i = radius.String(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func GGSNMCCMNC_Lookup(p *radius.Packet) (value []byte, err error) {
	a, ok := p.Lookup(GGSNMCCMNC_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.Bytes(a)
	return
}

func GGSNMCCMNC_LookupString(p *radius.Packet) (value string, err error) {
	a, ok := p.Lookup(GGSNMCCMNC_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.String(a)
	return
}

func GGSNMCCMNC_Set(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Set(GGSNMCCMNC_Type, a)
	return
}

func GGSNMCCMNC_SetString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Set(GGSNMCCMNC_Type, a)
	return
}

func GGSNMCCMNC_Del(p *radius.Packet) {
	p.Attributes.Del(GGSNMCCMNC_Type)
}

func NSAPI_Add(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Add(NSAPI_Type, a)
	return
}

func NSAPI_AddString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Add(NSAPI_Type, a)
	return
}

func NSAPI_Get(p *radius.Packet) (value []byte) {
	value, _ = NSAPI_Lookup(p)
	return
}

func NSAPI_GetString(p *radius.Packet) (value string) {
	value, _ = NSAPI_LookupString(p)
	return
}

func NSAPI_Gets(p *radius.Packet) (values [][]byte, err error) {
	var i []byte
	for _, avp := range p.Attributes {
		if avp.Type != NSAPI_Type {
			continue
		}
		attr := avp.Attribute
		i = radius.Bytes(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func NSAPI_GetStrings(p *radius.Packet) (values []string, err error) {
	var i string
	for _, avp := range p.Attributes {
		if avp.Type != NSAPI_Type {
			continue
		}
		attr := avp.Attribute
		i = radius.String(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func NSAPI_Lookup(p *radius.Packet) (value []byte, err error) {
	a, ok := p.Lookup(NSAPI_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.Bytes(a)
	return
}

func NSAPI_LookupString(p *radius.Packet) (value string, err error) {
	a, ok := p.Lookup(NSAPI_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.String(a)
	return
}

func NSAPI_Set(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Set(NSAPI_Type, a)
	return
}

func NSAPI_SetString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Set(NSAPI_Type, a)
	return
}

func NSAPI_Del(p *radius.Packet) {
	p.Attributes.Del(NSAPI_Type)
}

func SessionStopIndicator_Add(p *radius.Packet, value byte) (err error) {
	a := radius.Attribute{value}
	p.Add(SessionStopIndicator_Type, a)
	return
}

func SessionStopIndicator_Get(p *radius.Packet) (value byte) {
	value, _ = SessionStopIndicator_Lookup(p)
	return
}

func SessionStopIndicator_Gets(p *radius.Packet) (values []byte, err error) {
	for _, avp := range p.Attributes {
		if avp.Type != SessionStopIndicator_Type {
			continue
		}
		attr := avp.Attribute
		if len(attr) != 1 {
			err = errors.New("invalid byte")
			return
		}
		values = append(values, attr[0])
	}
	return
}

func SessionStopIndicator_Lookup(p *radius.Packet) (value byte, err error) {
	a, ok := p.Lookup(SessionStopIndicator_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	if len(a) != 1 {
		err = errors.New("invalid byte")
		return
	}
	value = a[0]
	return
}

func SessionStopIndicator_Set(p *radius.Packet, value byte) (err error) {
	a := radius.Attribute{value}
	p.Set(SessionStopIndicator_Type, a)
	return
}

func SessionStopIndicator_Del(p *radius.Packet) {
	p.Attributes.Del(SessionStopIndicator_Type)
}

func SelectionMode_Add(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Add(SelectionMode_Type, a)
	return
}

func SelectionMode_AddString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Add(SelectionMode_Type, a)
	return
}

func SelectionMode_Get(p *radius.Packet) (value []byte) {
	value, _ = SelectionMode_Lookup(p)
	return
}

func SelectionMode_GetString(p *radius.Packet) (value string) {
	value, _ = SelectionMode_LookupString(p)
	return
}

func SelectionMode_Gets(p *radius.Packet) (values [][]byte, err error) {
	var i []byte
	for _, avp := range p.Attributes {
		if avp.Type != SelectionMode_Type {
			continue
		}
		attr := avp.Attribute
		i = radius.Bytes(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func SelectionMode_GetStrings(p *radius.Packet) (values []string, err error) {
	var i string
	for _, avp := range p.Attributes {
		if avp.Type != SelectionMode_Type {
			continue
		}
		attr := avp.Attribute
		i = radius.String(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func SelectionMode_Lookup(p *radius.Packet) (value []byte, err error) {
	a, ok := p.Lookup(SelectionMode_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.Bytes(a)
	return
}

func SelectionMode_LookupString(p *radius.Packet) (value string, err error) {
	a, ok := p.Lookup(SelectionMode_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.String(a)
	return
}

func SelectionMode_Set(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Set(SelectionMode_Type, a)
	return
}

func SelectionMode_SetString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Set(SelectionMode_Type, a)
	return
}

func SelectionMode_Del(p *radius.Packet) {
	p.Attributes.Del(SelectionMode_Type)
}

func ChargingCharacteristics_Add(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Add(ChargingCharacteristics_Type, a)
	return
}

func ChargingCharacteristics_AddString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Add(ChargingCharacteristics_Type, a)
	return
}

func ChargingCharacteristics_Get(p *radius.Packet) (value []byte) {
	value, _ = ChargingCharacteristics_Lookup(p)
	return
}

func ChargingCharacteristics_GetString(p *radius.Packet) (value string) {
	value, _ = ChargingCharacteristics_LookupString(p)
	return
}

func ChargingCharacteristics_Gets(p *radius.Packet) (values [][]byte, err error) {
	var i []byte
	for _, avp := range p.Attributes {
		if avp.Type != ChargingCharacteristics_Type {
			continue
		}
		attr := avp.Attribute
		i = radius.Bytes(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func ChargingCharacteristics_GetStrings(p *radius.Packet) (values []string, err error) {
	var i string
	for _, avp := range p.Attributes {
		if avp.Type != ChargingCharacteristics_Type {
			continue
		}
		attr := avp.Attribute
		i = radius.String(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func ChargingCharacteristics_Lookup(p *radius.Packet) (value []byte, err error) {
	a, ok := p.Lookup(ChargingCharacteristics_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.Bytes(a)
	return
}

func ChargingCharacteristics_LookupString(p *radius.Packet) (value string, err error) {
	a, ok := p.Lookup(ChargingCharacteristics_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.String(a)
	return
}

func ChargingCharacteristics_Set(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Set(ChargingCharacteristics_Type, a)
	return
}

func ChargingCharacteristics_SetString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Set(ChargingCharacteristics_Type, a)
	return
}

func ChargingCharacteristics_Del(p *radius.Packet) {
	p.Attributes.Del(ChargingCharacteristics_Type)
}

func ChargingGatewayIPv6Address_Add(p *radius.Packet, value net.IP) (err error) {
	var a radius.Attribute
	a, err = radius.NewIPv6Addr(value)
	if err != nil {
		return
	}
	p.Add(ChargingGatewayIPv6Address_Type, a)
	return
}

func ChargingGatewayIPv6Address_Get(p *radius.Packet) (value net.IP) {
	value, _ = ChargingGatewayIPv6Address_Lookup(p)
	return
}

func ChargingGatewayIPv6Address_Gets(p *radius.Packet) (values []net.IP, err error) {
	var i net.IP
	for _, avp := range p.Attributes {
		if avp.Type != ChargingGatewayIPv6Address_Type {
			continue
		}
		attr := avp.Attribute
		i, err = radius.IPv6Addr(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func ChargingGatewayIPv6Address_Lookup(p *radius.Packet) (value net.IP, err error) {
	a, ok := p.Lookup(ChargingGatewayIPv6Address_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value, err = radius.IPv6Addr(a)
	return
}

func ChargingGatewayIPv6Address_Set(p *radius.Packet, value net.IP) (err error) {
	var a radius.Attribute
	a, err = radius.NewIPv6Addr(value)
	if err != nil {
		return
	}
	p.Set(ChargingGatewayIPv6Address_Type, a)
	return
}

func ChargingGatewayIPv6Address_Del(p *radius.Packet) {
	p.Attributes.Del(ChargingGatewayIPv6Address_Type)
}

func SGSNIPv6Address_Add(p *radius.Packet, value net.IP) (err error) {
	var a radius.Attribute
	a, err = radius.NewIPv6Addr(value)
	if err != nil {
		return
	}
	p.Add(SGSNIPv6Address_Type, a)
	return
}

func SGSNIPv6Address_Get(p *radius.Packet) (value net.IP) {
	value, _ = SGSNIPv6Address_Lookup(p)
	return
}

func SGSNIPv6Address_Gets(p *radius.Packet) (values []net.IP, err error) {
	var i net.IP
	for _, avp := range p.Attributes {
		if avp.Type != SGSNIPv6Address_Type {
			continue
		}
		attr := avp.Attribute
		i, err = radius.IPv6Addr(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func SGSNIPv6Address_Lookup(p *radius.Packet) (value net.IP, err error) {
	a, ok := p.Lookup(SGSNIPv6Address_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value, err = radius.IPv6Addr(a)
	return
}

func SGSNIPv6Address_Set(p *radius.Packet, value net.IP) (err error) {
	var a radius.Attribute
	a, err = radius.NewIPv6Addr(value)
	if err != nil {
		return
	}
	p.Set(SGSNIPv6Address_Type, a)
	return
}

func SGSNIPv6Address_Del(p *radius.Packet) {
	p.Attributes.Del(SGSNIPv6Address_Type)
}

func GGSNIPv6Address_Add(p *radius.Packet, value net.IP) (err error) {
	var a radius.Attribute
	a, err = radius.NewIPv6Addr(value)
	if err != nil {
		return
	}
	p.Add(GGSNIPv6Address_Type, a)
	return
}

func GGSNIPv6Address_Get(p *radius.Packet) (value net.IP) {
	value, _ = GGSNIPv6Address_Lookup(p)
	return
}

func GGSNIPv6Address_Gets(p *radius.Packet) (values []net.IP, err error) {
	var i net.IP
	for _, avp := range p.Attributes {
		if avp.Type != GGSNIPv6Address_Type {
			continue
		}
		attr := avp.Attribute
		i, err = radius.IPv6Addr(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func GGSNIPv6Address_Lookup(p *radius.Packet) (value net.IP, err error) {
	a, ok := p.Lookup(GGSNIPv6Address_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value, err = radius.IPv6Addr(a)
	return
}

func GGSNIPv6Address_Set(p *radius.Packet, value net.IP) (err error) {
	var a radius.Attribute
	a, err = radius.NewIPv6Addr(value)
	if err != nil {
		return
	}
	p.Set(GGSNIPv6Address_Type, a)
	return
}

func GGSNIPv6Address_Del(p *radius.Packet) {
	p.Attributes.Del(GGSNIPv6Address_Type)
}

func IPv6DNSServers_Add(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Add(IPv6DNSServers_Type, a)
	return
}

func IPv6DNSServers_AddString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Add(IPv6DNSServers_Type, a)
	return
}

func IPv6DNSServers_Get(p *radius.Packet) (value []byte) {
	value, _ = IPv6DNSServers_Lookup(p)
	return
}

func IPv6DNSServers_GetString(p *radius.Packet) (value string) {
	value, _ = IPv6DNSServers_LookupString(p)
	return
}

func IPv6DNSServers_Gets(p *radius.Packet) (values [][]byte, err error) {
	var i []byte
	for _, avp := range p.Attributes {
		if avp.Type != IPv6DNSServers_Type {
			continue
		}
		attr := avp.Attribute
		i = radius.Bytes(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func IPv6DNSServers_GetStrings(p *radius.Packet) (values []string, err error) {
	var i string
	for _, avp := range p.Attributes {
		if avp.Type != IPv6DNSServers_Type {
			continue
		}
		attr := avp.Attribute
		i = radius.String(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func IPv6DNSServers_Lookup(p *radius.Packet) (value []byte, err error) {
	a, ok := p.Lookup(IPv6DNSServers_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.Bytes(a)
	return
}

func IPv6DNSServers_LookupString(p *radius.Packet) (value string, err error) {
	a, ok := p.Lookup(IPv6DNSServers_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.String(a)
	return
}

func IPv6DNSServers_Set(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Set(IPv6DNSServers_Type, a)
	return
}

func IPv6DNSServers_SetString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Set(IPv6DNSServers_Type, a)
	return
}

func IPv6DNSServers_Del(p *radius.Packet) {
	p.Attributes.Del(IPv6DNSServers_Type)
}

func SGSNMCCMNC_Add(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Add(SGSNMCCMNC_Type, a)
	return
}

func SGSNMCCMNC_AddString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Add(SGSNMCCMNC_Type, a)
	return
}

func SGSNMCCMNC_Get(p *radius.Packet) (value []byte) {
	value, _ = SGSNMCCMNC_Lookup(p)
	return
}

func SGSNMCCMNC_GetString(p *radius.Packet) (value string) {
	value, _ = SGSNMCCMNC_LookupString(p)
	return
}

func SGSNMCCMNC_Gets(p *radius.Packet) (values [][]byte, err error) {
	var i []byte
	for _, avp := range p.Attributes {
		if avp.Type != SGSNMCCMNC_Type {
			continue
		}
		attr := avp.Attribute
		i = radius.Bytes(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func SGSNMCCMNC_GetStrings(p *radius.Packet) (values []string, err error) {
	var i string
	for _, avp := range p.Attributes {
		if avp.Type != SGSNMCCMNC_Type {
			continue
		}
		attr := avp.Attribute
		i = radius.String(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func SGSNMCCMNC_Lookup(p *radius.Packet) (value []byte, err error) {
	a, ok := p.Lookup(SGSNMCCMNC_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.Bytes(a)
	return
}

func SGSNMCCMNC_LookupString(p *radius.Packet) (value string, err error) {
	a, ok := p.Lookup(SGSNMCCMNC_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.String(a)
	return
}

func SGSNMCCMNC_Set(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Set(SGSNMCCMNC_Type, a)
	return
}

func SGSNMCCMNC_SetString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Set(SGSNMCCMNC_Type, a)
	return
}

func SGSNMCCMNC_Del(p *radius.Packet) {
	p.Attributes.Del(SGSNMCCMNC_Type)
}

func TeardownIndicator_Add(p *radius.Packet, value byte) (err error) {
	a := radius.Attribute{value}
	p.Add(TeardownIndicator_Type, a)
	return
}

func TeardownIndicator_Get(p *radius.Packet) (value byte) {
	value, _ = TeardownIndicator_Lookup(p)
	return
}

func TeardownIndicator_Gets(p *radius.Packet) (values []byte, err error) {
	for _, avp := range p.Attributes {
		if avp.Type != TeardownIndicator_Type {
			continue
		}
		attr := avp.Attribute
		if len(attr) != 1 {
			err = errors.New("invalid byte")
			return
		}
		values = append(values, attr[0])
	}
	return
}

func TeardownIndicator_Lookup(p *radius.Packet) (value byte, err error) {
	a, ok := p.Lookup(TeardownIndicator_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	if len(a) != 1 {
		err = errors.New("invalid byte")
		return
	}
	value = a[0]
	return
}

func TeardownIndicator_Set(p *radius.Packet, value byte) (err error) {
	a := radius.Attribute{value}
	p.Set(TeardownIndicator_Type, a)
	return
}

func TeardownIndicator_Del(p *radius.Packet) {
	p.Attributes.Del(TeardownIndicator_Type)
}

func IMEISV_Add(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Add(IMEISV_Type, a)
	return
}

func IMEISV_AddString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Add(IMEISV_Type, a)
	return
}

func IMEISV_Get(p *radius.Packet) (value []byte) {
	value, _ = IMEISV_Lookup(p)
	return
}

func IMEISV_GetString(p *radius.Packet) (value string) {
	value, _ = IMEISV_LookupString(p)
	return
}

func IMEISV_Gets(p *radius.Packet) (values [][]byte, err error) {
	var i []byte
	for _, avp := range p.Attributes {
		if avp.Type != IMEISV_Type {
			continue
		}
		attr := avp.Attribute
		i = radius.Bytes(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func IMEISV_GetStrings(p *radius.Packet) (values []string, err error) {
	var i string
	for _, avp := range p.Attributes {
		if avp.Type != IMEISV_Type {
			continue
		}
		attr := avp.Attribute
		i = radius.String(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func IMEISV_Lookup(p *radius.Packet) (value []byte, err error) {
	a, ok := p.Lookup(IMEISV_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.Bytes(a)
	return
}

func IMEISV_LookupString(p *radius.Packet) (value string, err error) {
	a, ok := p.Lookup(IMEISV_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.String(a)
	return
}

func IMEISV_Set(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Set(IMEISV_Type, a)
	return
}

func IMEISV_SetString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Set(IMEISV_Type, a)
	return
}

func IMEISV_Del(p *radius.Packet) {
	p.Attributes.Del(IMEISV_Type)
}

func RATType_Add(p *radius.Packet, value byte) (err error) {
	a := radius.Attribute{value}
	p.Add(RATType_Type, a)
	return
}

func RATType_Get(p *radius.Packet) (value byte) {
	value, _ = RATType_Lookup(p)
	return
}

func RATType_Gets(p *radius.Packet) (values []byte, err error) {
	for _, avp := range p.Attributes {
		if avp.Type != RATType_Type {
			continue
		}
		attr := avp.Attribute
		if len(attr) != 1 {
			err = errors.New("invalid byte")
			return
		}
		values = append(values, attr[0])
	}
	return
}

func RATType_Lookup(p *radius.Packet) (value byte, err error) {
	a, ok := p.Lookup(RATType_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	if len(a) != 1 {
		err = errors.New("invalid byte")
		return
	}
	value = a[0]
	return
}

func RATType_Set(p *radius.Packet, value byte) (err error) {
	a := radius.Attribute{value}
	p.Set(RATType_Type, a)
	return
}

func RATType_Del(p *radius.Packet) {
	p.Attributes.Del(RATType_Type)
}

func LocationInfo_Add(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Add(LocationInfo_Type, a)
	return
}

func LocationInfo_AddString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Add(LocationInfo_Type, a)
	return
}

func LocationInfo_Get(p *radius.Packet) (value []byte) {
	value, _ = LocationInfo_Lookup(p)
	return
}

func LocationInfo_GetString(p *radius.Packet) (value string) {
	value, _ = LocationInfo_LookupString(p)
	return
}

func LocationInfo_Gets(p *radius.Packet) (values [][]byte, err error) {
	var i []byte
	for _, avp := range p.Attributes {
		if avp.Type != LocationInfo_Type {
			continue
		}
		attr := avp.Attribute
		i = radius.Bytes(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func LocationInfo_GetStrings(p *radius.Packet) (values []string, err error) {
	var i string
	for _, avp := range p.Attributes {
		if avp.Type != LocationInfo_Type {
			continue
		}
		attr := avp.Attribute
		i = radius.String(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func LocationInfo_Lookup(p *radius.Packet) (value []byte, err error) {
	a, ok := p.Lookup(LocationInfo_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.Bytes(a)
	return
}

func LocationInfo_LookupString(p *radius.Packet) (value string, err error) {
	a, ok := p.Lookup(LocationInfo_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.String(a)
	return
}

func LocationInfo_Set(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Set(LocationInfo_Type, a)
	return
}

func LocationInfo_SetString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Set(LocationInfo_Type, a)
	return
}

func LocationInfo_Del(p *radius.Packet) {
	p.Attributes.Del(LocationInfo_Type)
}

type MSTimeZone uint32

var MSTimeZone_Strings = map[MSTimeZone]string{}

func (a MSTimeZone) String() string {
	if str, ok := MSTimeZone_Strings[a]; ok {
		return str
	}
	return "MSTimeZone(" + strconv.FormatUint(uint64(a), 10) + ")"
}

func MSTimeZone_Add(p *radius.Packet, value MSTimeZone) (err error) {
	a := radius.NewInteger(uint32(value))
	p.Add(MSTimeZone_Type, a)
	return
}

func MSTimeZone_Get(p *radius.Packet) (value MSTimeZone) {
	value, _ = MSTimeZone_Lookup(p)
	return
}

func MSTimeZone_Gets(p *radius.Packet) (values []MSTimeZone, err error) {
	var i uint32
	for _, avp := range p.Attributes {
		if avp.Type != MSTimeZone_Type {
			continue
		}
		attr := avp.Attribute
		i, err = radius.Integer(attr)
		if err != nil {
			return
		}
		values = append(values, MSTimeZone(i))
	}
	return
}

func MSTimeZone_Lookup(p *radius.Packet) (value MSTimeZone, err error) {
	a, ok := p.Lookup(MSTimeZone_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	var i uint32
	i, err = radius.Integer(a)
	if err != nil {
		return
	}
	value = MSTimeZone(i)
	return
}

func MSTimeZone_Set(p *radius.Packet, value MSTimeZone) (err error) {
	a := radius.NewInteger(uint32(value))
	p.Set(MSTimeZone_Type, a)
	return
}

func MSTimeZone_Del(p *radius.Packet) {
	p.Attributes.Del(MSTimeZone_Type)
}

func CamelChargingInfo_Add(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Add(CamelChargingInfo_Type, a)
	return
}

func CamelChargingInfo_AddString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Add(CamelChargingInfo_Type, a)
	return
}

func CamelChargingInfo_Get(p *radius.Packet) (value []byte) {
	value, _ = CamelChargingInfo_Lookup(p)
	return
}

func CamelChargingInfo_GetString(p *radius.Packet) (value string) {
	value, _ = CamelChargingInfo_LookupString(p)
	return
}

func CamelChargingInfo_Gets(p *radius.Packet) (values [][]byte, err error) {
	var i []byte
	for _, avp := range p.Attributes {
		if avp.Type != CamelChargingInfo_Type {
			continue
		}
		attr := avp.Attribute
		i = radius.Bytes(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func CamelChargingInfo_GetStrings(p *radius.Packet) (values []string, err error) {
	var i string
	for _, avp := range p.Attributes {
		if avp.Type != CamelChargingInfo_Type {
			continue
		}
		attr := avp.Attribute
		i = radius.String(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func CamelChargingInfo_Lookup(p *radius.Packet) (value []byte, err error) {
	a, ok := p.Lookup(CamelChargingInfo_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.Bytes(a)
	return
}

func CamelChargingInfo_LookupString(p *radius.Packet) (value string, err error) {
	a, ok := p.Lookup(CamelChargingInfo_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.String(a)
	return
}

func CamelChargingInfo_Set(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Set(CamelChargingInfo_Type, a)
	return
}

func CamelChargingInfo_SetString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Set(CamelChargingInfo_Type, a)
	return
}

func CamelChargingInfo_Del(p *radius.Packet) {
	p.Attributes.Del(CamelChargingInfo_Type)
}

func PacketFilter_Add(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Add(PacketFilter_Type, a)
	return
}

func PacketFilter_AddString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Add(PacketFilter_Type, a)
	return
}

func PacketFilter_Get(p *radius.Packet) (value []byte) {
	value, _ = PacketFilter_Lookup(p)
	return
}

func PacketFilter_GetString(p *radius.Packet) (value string) {
	value, _ = PacketFilter_LookupString(p)
	return
}

func PacketFilter_Gets(p *radius.Packet) (values [][]byte, err error) {
	var i []byte
	for _, avp := range p.Attributes {
		if avp.Type != PacketFilter_Type {
			continue
		}
		attr := avp.Attribute
		i = radius.Bytes(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func PacketFilter_GetStrings(p *radius.Packet) (values []string, err error) {
	var i string
	for _, avp := range p.Attributes {
		if avp.Type != PacketFilter_Type {
			continue
		}
		attr := avp.Attribute
		i = radius.String(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func PacketFilter_Lookup(p *radius.Packet) (value []byte, err error) {
	a, ok := p.Lookup(PacketFilter_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.Bytes(a)
	return
}

func PacketFilter_LookupString(p *radius.Packet) (value string, err error) {
	a, ok := p.Lookup(PacketFilter_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.String(a)
	return
}

func PacketFilter_Set(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Set(PacketFilter_Type, a)
	return
}

func PacketFilter_SetString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Set(PacketFilter_Type, a)
	return
}

func PacketFilter_Del(p *radius.Packet) {
	p.Attributes.Del(PacketFilter_Type)
}

func NegotiatedDSCP_Add(p *radius.Packet, value byte) (err error) {
	a := radius.Attribute{value}
	p.Add(NegotiatedDSCP_Type, a)
	return
}

func NegotiatedDSCP_Get(p *radius.Packet) (value byte) {
	value, _ = NegotiatedDSCP_Lookup(p)
	return
}

func NegotiatedDSCP_Gets(p *radius.Packet) (values []byte, err error) {
	for _, avp := range p.Attributes {
		if avp.Type != NegotiatedDSCP_Type {
			continue
		}
		attr := avp.Attribute
		if len(attr) != 1 {
			err = errors.New("invalid byte")
			return
		}
		values = append(values, attr[0])
	}
	return
}

func NegotiatedDSCP_Lookup(p *radius.Packet) (value byte, err error) {
	a, ok := p.Lookup(NegotiatedDSCP_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	if len(a) != 1 {
		err = errors.New("invalid byte")
		return
	}
	value = a[0]
	return
}

func NegotiatedDSCP_Set(p *radius.Packet, value byte) (err error) {
	a := radius.Attribute{value}
	p.Set(NegotiatedDSCP_Type, a)
	return
}

func NegotiatedDSCP_Del(p *radius.Packet) {
	p.Attributes.Del(NegotiatedDSCP_Type)
}

func AllocateIPType_Add(p *radius.Packet, value byte) (err error) {
	a := radius.Attribute{value}
	p.Add(AllocateIPType_Type, a)
	return
}

func AllocateIPType_Get(p *radius.Packet) (value byte) {
	value, _ = AllocateIPType_Lookup(p)
	return
}

func AllocateIPType_Gets(p *radius.Packet) (values []byte, err error) {
	for _, avp := range p.Attributes {
		if avp.Type != AllocateIPType_Type {
			continue
		}
		attr := avp.Attribute
		if len(attr) != 1 {
			err = errors.New("invalid byte")
			return
		}
		values = append(values, attr[0])
	}
	return
}

func AllocateIPType_Lookup(p *radius.Packet) (value byte, err error) {
	a, ok := p.Lookup(AllocateIPType_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	if len(a) != 1 {
		err = errors.New("invalid byte")
		return
	}
	value = a[0]
	return
}

func AllocateIPType_Set(p *radius.Packet, value byte) (err error) {
	a := radius.Attribute{value}
	p.Set(AllocateIPType_Type, a)
	return
}

func AllocateIPType_Del(p *radius.Packet) {
	p.Attributes.Del(AllocateIPType_Type)
}
